#include <bits/stdc++.h>

using namespace std;

void count_sort( vector<int> &p, vector<int> &c )
{
    int n = p.size();
    vector<int> cnt(n);
    for ( auto x:c ) {
        cnt[x]++;
    }
    vector<int> p_new(n);
    vector<int> pos(n);
    pos[0] = 0;
    for ( int i = 1; i < n; i++ ) {
        pos[i] = pos[i - 1] + cnt[i - 1];
    }

    for ( auto x:p ) {
        int i = c[x];
        p_new[pos[i]] = x;
        pos[i]++;
    }
    p = p_new;
}

void radix_sort( vector<pair<pair<int, int>, int>> &a )
{
    int n = a.size();
    {
        vector<int> cnt(n);
        for ( auto it: a ) {
            cnt[it.first.second]++;
        }
        vector<pair<pair<int, int>, int>> a_new(n);
        vector<int> pos(n);
        pos[0] = 0;
        for ( int i = 1; i < n; i++ ) {
            pos[i] = pos[i - 1] + cnt[i - 1];
        }
        for ( auto it:a ) {
            int i = it.first.second;
            a_new[pos[i]] = it;
            pos[i]++;
        }
        a = a_new;
    }
    {
        vector<int> cnt(n);
        for ( auto it: a ) {
            cnt[it.first.first]++;
        }
        vector<pair<pair<int, int>, int>> a_new(n);
        vector<int> pos(n);
        pos[0] = 0;
        for ( int i = 1; i < n; i++ ) {
            pos[i] = pos[i - 1] + cnt[i - 1];
        }
        for ( auto it:a ) {
            int i = it.first.first;
            a_new[pos[i]] = it;
            pos[i]++;
        }
        a = a_new;
    }
}

bool isPrefix( string &a, string &b )
{
    int t = 0;
    while ( t < a.size()) {
        if ( t >= b.size()) return false;
        if ( a[t] != b[t] ) return false;
        t++;
    }
    return true;
}

int binary_search( string &s, vector<int> &p, string &ss )
{
    int cnt = 0, cut = s.size();
    int l = 0, r = p.size() - 1;
    int x = -1;
    while ( l <= r ) {
        int mid = (l + r) >> 1;
        string tmp = ss.substr(p[mid], cut);
        if ( tmp < s ) l = mid + 1;
        else if ( tmp > s ) r = mid - 1;
        else {
            x = mid;
            cnt++;
            break;
        }
    }
    if ( x == -1 ) return 0;
    string tmp;
    int t;
    int tl = x - 1, tr = x + 1;
    while ( tl >= 0 ) {
        tmp = ss.substr(p[tl]);
        if ( isPrefix(s, tmp)) cnt++;
        else break;
        tl--;
    }
    while ( tr < ss.size()) {
        tmp = ss.substr(p[tr]);
        if ( isPrefix(s, tmp)) cnt++;
        else break;
        tr++;
    }
//    for(int i=1; i<p.size(); i++){
//        if(x-i>=0){
//            t=x-i;
//            tmp=ss.substr(p[t]);
//            int tt=0;
//            while(tt<s.size()){
//                if(tt>tmp.size()) break;
//                if(s[tt]!=tmp[tt]) break;
//                tt++;
//            }
//            if(tt==s.size()) cnt++;
//        }
//        if(x+i<ss.size()){
//            t=x+i;
//            tmp=ss.substr(p[t]);
//            int tt=0;
//            while(tt<s.size()){
//                if(tt>tmp.size()) break;
//                if(s[tt]!=tmp[tt]) break;
//                tt++;
//            }
//            if(tt==s.size()) cnt++;
//        }
//    }
    return cnt;
}

int main()
{
    freopen("test.txt", "r", stdin);
    string s;
    cin >> s;
    s += "$";
    int n = s.size();
    vector<int> p(n), c(n);
    {
        //k=0
        vector<pair<char, int>> a(n);
        for ( int i = 0; i < n; i++ ) a[i] = {s[i], i};
        sort(a.begin(), a.end());

        for ( int i = 0; i < n; i++ ) p[i] = a[i].second;
        c[p[0]] = 0;
        for ( int i = 1; i < n; i++ ) {
            if ( a[i].first == a[i - 1].first ) {
                c[p[i]] = c[p[i - 1]];
            } else {
                c[p[i]] = c[p[i - 1]] + 1;
            }
        }
    }

    int k = 0;
    while ((1 << k) < n ) {
        //k->k+1
//        vector<pair<pair<int, int>, int>> a(n);
//        for(int i=0; i<n; i++){
//            a[i]={{c[i], c[(i+(1<<k))%n]}, i};
//        }
//        radix_sort(a);

        for ( int i = 0; i < n; i++ ) {
            p[i] = (p[i] - (1 << k) + n) % n;
        }

        count_sort(p, c);

        vector<int> c_new(n);
        c_new[p[0]] = 0;
        for ( int i = 1; i < n; i++ ) {
            pair<int, int> prev = {c[p[i - 1]], c[(p[i - 1] + (1 << k)) % n]};
            pair<int, int> now = {c[p[i]], c[(p[i] + (1 << k)) % n]};
            if ( prev == now ) {
                c_new[p[i]] = c_new[p[i - 1]];
            } else {
                c_new[p[i]] = c_new[p[i - 1]] + 1;
            }
        }
        c = c_new;
//        for(int i=0; i<n; i++) p[i]=a[i].second;
//        c[p[0]]=0;
//        for(int i=1; i<n; i++){
//            if(a[i].first==a[i-1].first){
//                c[p[i]]=c[p[i-1]];
//            } else {
//                c[p[i]]=c[p[i-1]]+1;
//            }
//        }
        k++;
    }
    int q;
    cin >> q;
    while ( q-- ) {
        string tmp;
        cin >> tmp;
        int t = binary_search(tmp, p, s);
        cout << t << endl;
    }
}
